# ConcurrentHashMap
在工作中大量使用了这个类，线程安全且并发度较高。
## 1.8版本之前
通过分段加锁实现并发读写，内部维护了一个`Segment<K,V>[]`数组，Segment本质是一个hashtable，hashMap读写的基本单位就是Segment，在冲突的时候使用链表来维护`Entry`
## 1.8版本以上
- 1.8版本抛弃了`Segment`的分段方式，不过为了兼容性在源码里还有。 
- 在Map中通过一个`Node<K,V>[]`数组来维护数据，而在数组同一个位置则通过链表或者红黑树的方式来保存。
- 在数组同一位置的元素超过8个之后会判断Node数组数量，如果小于64则会对数组进行reHash并将元素分散，如果达到了64则将链表改为红黑树结构
- 每一个Node节点都会被单独加锁，相当于一个Segment
